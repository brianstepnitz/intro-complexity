## WHAT IS IT?

This model attempts to use NetLogo to replicate the findings from Mitchell, Melanie and James P. Crutch. “Evolving Cellular Automata with Genetic Algorithms: A Review of Recent Work.” (2000). It uses a Genetic Algorithm to search for a one dimensional Cellular Automaton that will always converge to all cells being in the same state in which the majority of cells started. It was completed as part of the coursework for the "Introduction to Complexity" class held by Complexity Explorer ( https://www.complexityexplorer.org/courses/119-introduction-to-complexity ) Unit 6: "Cellular Automata".

## HOW IT WORKS

### Gnomes in Hats

In trying to develop some intuition for the problem, I reached for a common setup in mathematical puzzles of Gnomes in Hats (representative example [here](https://www.intelliot.com/2004/09/gnomes-puzzle/) although there are many varieties). So for this assignment, my setup was: you have an odd number of gnomes in a circle where each gnome wears a White hat or a Black hat. Each gnome can only see its own hat and the hats of some number of gnomes to their left and two gnomes to their right and otherwise cannot see any other gnomes nor can they communicate with any gnomes. At each timestep, each gnome can look at the hats they can see, and then all gnomes simultaneously and instantaneously decide to either keep their hat or put on the other color of hat. The goal is for every gnome in the circle to end up wearing the same color of hat that the majority of ALL gnomes in the cirlce were wearing at the very first timestep. Is there a uniform set of rules that every gnome can independently follow to achieve that result?

I thought of each gnome having a "codebook" that every gnome shared and that they could refer to when deciding whether to change hats. "Okay, for me and the six other gnomes I can see, we are in pattern WWWBWWW. Looking up that pattern, the codebook says I should change my hat to White. Got it.". Now, there are stupendously many possible such codebooks, so the assignment is to use a Genetic Algorithm to try to find a codebook gives the gnomes the strategy to succeed.

### Genetic Algorithm

When the model begins, it generates a population of "codebooks" by randomly varying the density between 0 and 1 and generating a random codebook of that density. It then generates a number of random "lineups" by randomly varying the density between 0 and 1 for the configured number of trials. For each codebook in the population, it runs it on each lineup for a random number of iterations drawn from a Poisson distribution with the configured mean. If the codebook successfully classifies the lineup, it increases its fitness. No partial credit is given.

The configured percentage of top fitness codebooks are kept, and new codebooks are generated by crossing over two random codebooks from among the kept elite. Crossover is achieved by slicing the two codebooks in the same random position and combining the two parts together. Then, the new codebook is mutated the configured number of times in random positions.

This new generation of codebooks then repeats the process, until the configured number of generations have passed.

### Representation

As a row of black and white cells, a "lineup" can easily be represented as a binary number. A "lineup id" is the hexadecimal representation of this binary number.

A "codebook" is a list of rules for every possible local neighborhood in the lineup. If there are 7 gnomes in a neighborhood as in the paper, there are 2^7 = 128 possible neighborhoods to have in the codebook. So a codebook can be just a listing of the 128 states that each possible neighborhood generates in the next iteration, in lexicographic order of the neighborhoods from 0000000 to 1111111. This listing itself can be represented as a 128 bit binary number. A "codebook id" is the hexadecimal representation of that binary number.

## HOW TO USE IT

### The Genetic Algorithm component

* `sight-range` controls how many gnomes each gnome can see in each direction. So a "sight range" of 3 would mean each gnome can see 3 gnomes to the left and 3 gnomes to the right (as well as itself) for a total of being able to see 7 gnomes.
* `lineup-width` controls how many "gnomes" are in the circle.
* `trial-increments` controls how much each codebook is tested. For each 0 ≤ _trial_ ≤ `trial-increments`, the algorithm generates a random lineup with _trial_ / `trial-increments` gnomes in black hats (and the rest in in white hats) and then runs the codebook on that lineup.
* `mean-iterations` controls the average number of iterations that the codebook Cellular Automaton will run each iteration before being checked for fitness. As in the referenced paper, this number is drawn from a Poisson distribution instead of being fixed so that the Genetic Algorithm doesn't specialize for only a specific number of iterations.
* `num-codebooks` controls how many "codebooks" are in the population for the Genetic Algorithm.
* `num-generations` controls the number of generations that the Genetic Algorithm will run for.
* `selection` controls the proportion of codebooks with the highest fitness that are kept each generation.
* `mutation-count` controls the exact number of mutations that will occur after each crossover.

### The Lineup / Codebook Sandbox component

* `randomly-populate?` controls whether to randomly populate the initial lineup, which will then update the `lineup-id` to the new lineup, or to use that `lineup-id` to populate the initial lineup.
* `lineup-density` controls what density of white hats to contain in a randomly generated initial lineup.
* `lineup-id` is the hexadecimal representation of the initial lineup. Can be used to set what you want the initial lineup to be.
* `codebook-id` is the hexadecimal representation of what codebook to use to iterate the cellular automata.
* `Step Codebook` steps through a single iteration of the codebook on the current lineup.
* `Run Codebook` runs through a number of iterations of the codebook on the lineup equal to `mean-iterations`.

## THINGS TO NOTICE

The results closely mirror those found in the referenced paper. Early successes are those that always move towards all white or all black. Crossover helps find strategies that can move "mostly black hats" to "all black hats" and "mostly white hats" to "all white hats". The strategies struggle when the initial lineup is close to 50/50 white hat and black hat.

Also, as an interesting aside, in early versions of my model I didn't vary the number of iterations during fitness checking. An interesting strategy that evolved was for all of the gnomes to converge on SOME color, regardless of majority or not, and then "blink" back and forth between the colors, hoping that the simulation ended with the right color showing.

## THINGS TO TRY

At smaller values of `lineup-width`, the model completes quickly and often finds viable solutions.

The Lineup / Codebook sandbox provides a lot of intuiton for the problem.

## EXTENDING THE MODEL

The referenced paper contains many interesting ideas for extending this sort of model. A particular one of interest is that, because the sophisticated strategies get very good at solving low or high density lineups, their fitness seems artificially inflated by continuously testing them on those lineups. So, instead of always testing on a uniform distribution of densities, somehow incrementally increase the difficulty of the configurations that the strategies are tested on. Two possibilites of this are:

  1. Simply narrow the range of densities tested until it gets closer and closer to 50/50; --or--
  2. A more interesting proposal is to have the test lineups go through a genetic algorithm of their own, where the "fitter" ones are the ones that stump the most strategies. Then have the test lineups co-evolve with the strategies to solve them.


## CREDITS AND REFERENCES

Mitchell, Melanie and James P. Crutch. “Evolving Cellular Automata with Genetic Algorithms: A Review of Recent Work.” (2000).

## COPYRIGHT AND LICENSE

### The MIT License (MIT)

Copyright 2021 Brian Stepnitz

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.